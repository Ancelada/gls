<!DOCTYPE HTML>

<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Our WebGl</title>
		{% load staticfiles %}

		<script type="text/javascript" src="{% static 'js/vendor/jquery-2.2.0.js' %}"></script>
        <script type="text/javascript" src="{% static 'js/vendor/foundation.core.js' %}"></script>
        <script type="text/javascript" src="{% static 'js/attrchange.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/three.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/dat.gui.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/OrbitControls.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/stats.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/helvetiker_regular.typeface.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/ColladaLoader.js' %}"></script>
        <script type="text/javascript" src="{% static 'js/sockjs.min.js' %}"></script>

  		<link rel="stylesheet" href="{% static 'css/foundation.css' %}">
    	<link rel="stylesheet" href="{% static 'css/app.css' %}">


		<style>
			body{
				margin:0;
				overflow:hidden;
			}
		</style>
	</head>
	<body>
		{% csrf_token %}
		<!-- ***блок 3д изображения*** -->
		<!-- ************************ -->
		<div id ="webGL-container"></div>
		<button class="button large show_hide_button">Строения</button>
		<button class="button large show_hide_session_button">Настройка сессии</button>
		<!-- Блок интрументов -->
		<div class="instrument_block large-3 small-4 columns" style="right:-100%;">
			<fieldset class="large-12 small-12 columns">
				<button class="close-button close_panel" aria-label="Close menu" type="button">
                    <span aria-hidden="true">x</span>
                </button>
                <br>
			</fieldset>
		</div>
		<!-- Блок настройки сессии -->
		<div class="session_block large-3 small-4 columns" style="right:-100%;">
			<fieldset class="large-12 small-12 columns">
				<button class="close-button close_session_panel" aria-label="Close menu" type="button">
                    <span aria-hidden="true">x</span>
                </button>
                <br>
                <h3 class="subheader">Настройка сессии</h3>
                <fieldset>
                	<legend>Параметры сессии</legend>
                	<label for="sessionname">Наименование
                		<input type="text" id="sessionname" value="КБНТ">	
                	</label>
                	<label for="sessionpassword">Пароль
                		<input type="text" id="sessionpassword" value="1234">
                	</label>
                </fieldset>
                <fieldset>
                	<legend>Параметры сцены</legend>
                	<label for="layerid">Идентификатор
                		<input type="text" id="layerid" value="3">
                	</label>
                	<label for="layername">Наименование
                		<input type="text" id="layername" value="Подложка КБНТ">
                	</label>
                </fieldset>
                <span class="button succes" id="loadtodb">Записать параметры сессии</span>
                <span class="button secondary" id="sendsession">Отправить параметры новой сессии</span>
                <span class="button success" id="getsessionlist">Получить идентификаторы из списка сессий</span>
                <div id="notification"></div>
			</fieldset>
		</div>
    <!-- ***блок панель управления*** -->
    <!--************************-->
    <script>
    	var landscape_id = '{{landscape_id}}';
	    var colladaObjects = {};
        $.getScript("/static/js/additional/session_panel.js");
	    //json session для загрузки Андрею 
	    var session = {};
	    //наименование комманды
	    session['command'] = 'saveNewSession';
	    //ключ session
	    session['session'] = {};
	    session['session']['id'] = 0;
	    session['session']['inuse'] = 1;
	    //ключ layer
	    session['layer'] = {};
	    //левый верхний
	    session['layer']['latitude1'] = 0;
	    session['layer']['longitude1'] = 0;
	    session['layer']['height1'] = 0;
	    session['layer']['x1'] = 0;
	    session['layer']['y1'] = 0;
	    session['layer']['z1'] = 0;
	    //правый нижний
	    session['layer']['latitude2'] = 0;
	    session['layer']['longitude2'] = 0;
	    session['layer']['height2'] = 0;
	    session['layer']['x2'] = 0;
	    session['layer']['y2'] = 0;
	    session['layer']['z2'] = 0;
	    session['layer']['scaleX'] = 0;
	    session['layer']['scaleY'] = 0;
	    //планы
	    session['plans'] = [];
	    //дерево планов
	    session['plans_tree'] = [];
	    
	    function init(){
	    	/*сцена, камера */
		    scene = new THREE.Scene();
		    camera =  new THREE.PerspectiveCamera(85, window.innerWidth/window.innerHeight, .1, 1000);
		    renderer = new THREE.WebGLRenderer({antialias:true});
		    
		    /*рендерер;*/
		    renderer.setSize(window.innerWidth, window.innerHeight);
		    renderer.shadowMapEnabled= true;
		    renderer.shadowMapType = THREE.PCFSoftShadowMap;
		    
		    /*оси*/
		    axis = new THREE.AxisHelper(30);
		    scene.add(axis);

		    /* сетка */
		    grid = new THREE.GridHelper(100, 25);
		    color = new THREE.Color("rgb(255, 0, 0)");
		    grid.setColors(color, 0x000000);
		    grid.rotation.x = -0.5* Math.PI
		    /*scene.add(grid);*/

		    /* add collada import */
    		var loader = new THREE.ColladaLoader();
    		/*loader.options.convertUpAxis = true;*/

        	//**словарь настроек сцены (Camera up value, Camera position value, dae rotation z, x, y, light target position positive/negative, Cylinder positiven negative)
	        sceneOptions = {};

	        //маркеры калибровки
		    /*var markGeom = new THREE.BoxGeometry(0.5, 0.5, 0.5, 2, 2, 2);
		    var markMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
		    this.marker6004 = new THREE.Mesh(markGeom, markMaterial);
		    marker6004.position.set(76.457, 39.682, 7.6);
		    scene.add(marker6004);

		    this.marker6042 = new THREE.Mesh(markGeom, markMaterial);
		    marker6042.position.set(67.725, 39.850, 7.6);
		    scene.add(marker6042);

		    this.marker6003 = new THREE.Mesh(markGeom, markMaterial);
		    marker6003.position.set(59.531, 39.811 , 7.6);
		    scene.add(marker6003);

		    this.marker6045 = new THREE.Mesh(markGeom, markMaterial);
		    marker6045.position.set(76.426, 30.141, 8.7);
		    scene.add(marker6045);*/

		    loader.load( '/models/{{source}}', function ( collada ) {
				loader.options.convertUpAxis = true;
				//функция заполнения планов сессии для Андрея
				function fillSessionPlans(obj, objType){
					plan = {};
                    plan['id'] = obj.id;
                    plan['name'] = obj.name;
                    plan['description'] = '';
                    plan['x'] = obj.Center['y'];
                    plan['y'] = obj.BoxMin['z'];
                    plan['z'] = obj.Center['x'];
                    plan['sizex'] = Math.abs(obj.BoxMax.y - obj.BoxMin.y);
                    plan['sizey'] = Math.abs(obj.BoxMax.z - obj.BoxMin.z);
                    plan['sizez'] = Math.abs(obj.BoxMax.x - obj.BoxMin.x);
                    plan['angleRotateX'] = 0;
                    plan['angleRotateY'] = obj.Zangle;
                    plan['angleRotateZ'] = 0;
                    if (objType == 'building') {
                    	plan['objType'] = 2;	
                    } else if (objType == 'floor') {
                    	plan['objType'] = 3;
                    } else if (objType == 'kabinet'){
                    	plan['objType'] = 4;
                    }
                    return plan;
				}

				//функция преобразования относительных вершин к центру 0
				function relativeCenter(obj){
					var planeGeometry = new THREE.Geometry();
					$.each(obj.geometry.vertices, function(index){
						x = obj.geometry.vertices[index].x;
						y = obj.geometry.vertices[index].y;
						z = obj.geometry.vertices[index].z;
						planeGeometry.vertices.push(
							new THREE.Vector3(x, y, z)
						)
					});
					$.each(obj.geometry.faces, function(index){
						a = obj.geometry.faces[index].a;
						b = obj.geometry.faces[index].b;
						c = obj.geometry.faces[index].c;
						planeGeometry.faces.push(
							new THREE.Face3(a, b, c)
						)
					});
					planeGeometry.computeBoundingSphere();

					var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide});
					var p = new THREE.Mesh(planeGeometry, planeMaterial);
					var bbox = new THREE.Box3().setFromObject(p);
					a = getCenter(bbox);
					obj.geometry.relativeMin = bbox.min;
					obj.geometry.relativeMax = bbox.max;
					x = a['x']
					y = a['y']
					obj.geometry.relativeVertices = [];
					$.each(obj.geometry.vertices, function(index){
						obj.geometry.relativeVertices[index] = new THREE.Vector3(0, 0, 0);
					});
					if (x > 0 || x == 0) {
						$.each(obj.geometry.vertices, function(index){
							obj.geometry.relativeVertices[index].x = obj.geometry.vertices[index].x - x;
						});
					} else if (x < 0 || x == 0){
						$.each(obj.geometry.vertices, function(index){
							obj.geometry.relativeVertices[index].x = obj.geometry.vertices[index].x + x;
						});
					}
					if (y > 0 || y == 0) {
						$.each(obj.geometry.vertices, function(index){
							obj.geometry.relativeVertices[index].y = obj.geometry.vertices[index].y + y;
						});
					} else if (y < 0 || y == 0){
						$.each(obj.geometry.vertices, function(index){
							obj.geometry.relativeVertices[index].y = obj.geometry.vertices[index].y - y;
						});
					}
						//снова создаем объекты, чтобы найти min max
						var planeGeometry = new THREE.Geometry();
						$.each(obj.geometry.relativeVertices, function(index){
							x = obj.geometry.relativeVertices[index].x;
							y = obj.geometry.relativeVertices[index].y;
							z = 0;
							planeGeometry.vertices.push(
								new THREE.Vector3(x, y, z)
							)
						});
						$.each(obj.geometry.faces, function(index){
							a = obj.geometry.faces[index].a;
							b = obj.geometry.faces[index].b;
							c = obj.geometry.faces[index].c;
							planeGeometry.faces.push(
								new THREE.Face3(a, b, c)
							)
						});
						planeGeometry.computeBoundingSphere();

						var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide});
						var p = new THREE.Mesh(planeGeometry, planeMaterial);
						/*scene.add(p);*/
						var bbox = new THREE.Box3().setFromObject(p);
						obj.geometry.relativeMin = bbox.min;
						obj.geometry.relativeMax = bbox.max;
				}

		        //функция поиска центра collada объекта на оси координат
		        var getCenter = function(obj){
		            minx = obj.min.x;
		            miny = obj.min.y;
		            minz = obj.min.z;

		            maxx = obj.max.x;
		            maxy = obj.max.y;
		            maxz = obj.max.z;

		            x = (minx - maxx);
		            x = x - 2*x;

		            y = (miny - maxy);
		            y = y - 2*y;

		            z = (minz - maxz);
		            z = z - 2*z;

		            a = {}
		            a['x'] = minx + x/2;
		            a['y'] = miny + y/2;
		            a['z'] = minz + z/2;
		            return a;
		        }

		        //функция поиска угла поворота building по оси Z объекта
		       	function setZangle(dae, object){
		       		if (dae.children){
		       			for (var i = 0; i < dae.children.length; i ++){
		       				if(dae.children[i].colladaId == object.name){
		       					z = dae.children[i].rotation.z;
		       					object.Zangle = z;
		       					return false;
		       				} 
		       				setZangle(dae.children[i], object);
		       			}
		       		}
		       	}

		       	//функция обнуления Z у building
		       	function clearZ(dae, object, Zangle){
		       		if (dae.children){
		       			for (var i = 0; i < dae.children.length; i++){
		       				if(dae.children[i].colladaId == object.name){
		       					dae.children[i].rotation.z = 0 - Zangle;
		       					return false;
		       				}
		       				clearZ(dae.children[i], object, Zangle);
		       			}
		       		}
		       	}

		    	//gls.dae
		    	var dae = collada.scene;
		    	/*dae.position.set(72,29,6);*/
		    	/*x = 72;
		    	y = 29;
		    	z = 6;*/
		    	x = 76.639466894532;
		    	y = 74.03660739746092645;
		    	z = 6;
		    	dae.position.set(x, y, z);
		    	sceneOptions['DaePosition'] = {};
		    	sceneOptions['DaePosition'].x = x;
		    	sceneOptions['DaePosition'].y = y;
		    	sceneOptions['DaePosition'].z = z;
		    	dae.scale.set(1,1,1);
		    	scene.add(dae);


		        //****************************
		        //**заполняем массив элементов сцены
		        //****************************

		        //**дерево
		        colladaObjects['landscape'] = [];
		        //**вершины
		        verticesDict = {};
		        verticesDict['element'] = [];

		        //**наполняем landscape
		        colladaObjects['landscape'].push(dae['children'][0]['children'][0]);
		        colladaObjects['landscape'][0].name = colladaObjects['landscape'][0]['parent']['name'];
		            // ищем центр landscape
		            lndscp = dae;
		            var bbox = new THREE.Box3().setFromObject(lndscp);
		            landscape = colladaObjects['landscape'][0];
		            a = getCenter(bbox);
		            landscape.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		            landscape.BoxMin = bbox['min'];
		            landscape.BoxMax = bbox['max'];
		            session['layer']['x1'] = parseFloat(Math.round(landscape.BoxMin['y']).toFixed(0));//0z
		            session['layer']['y1'] = parseFloat(Math.round(landscape.BoxMin['x']).toFixed(0));//0y
		            session['layer']['z1'] = landscape.BoxMin['z'];//0x
		            session['layer']['x2'] = landscape.BoxMax['y'];//149z2
		            session['layer']['y2'] = landscape.BoxMax['x'];//149y2
		            session['layer']['z2'] = landscape.BoxMin['z'];//0x
		            //добавляем свойство Z angle
		            setZangle(dae, landscape);
		        //**наполняем building
		        var no = 0;
		        $.each(colladaObjects['landscape'][0].parent.children, function(value){
		            var landscape = colladaObjects['landscape'][0].parent.children[value];
		            if (landscape.name.indexOf('building') != -1){
		                colladaObjects['landscape'][0].children.push(landscape.children[0]);
		                colladaObjects['landscape'][0]['children'][no]['name'] = colladaObjects['landscape'][0]['children'][no]['parent']['name'];
		                	bld = colladaObjects['landscape'][0].children[no];
		                    //добавляем свойство Z angle
		                    setZangle(dae, bld);
		                    //обнуляем Z
		                    clearZ(dae, bld, colladaObjects['landscape'][0]['Zangle']);
		                    // ищем центр building
		                    var bbox = new THREE.Box3().setFromObject(bld.parent);
		                    bld.BoxMin = bbox['min'];
		                    bld.BoxMax = bbox['max'];
		                    a = getCenter(bbox);
		                    bld.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                    //заполняем session['plans'] buildings
		                    session['plans'].push(fillSessionPlans(bld, 'building'));
		                    //заполняем session['PLANS_TREE']
		                    session['plans_tree'].push({'id': bld.id, 'idparent': -1});
		                    //приводим относительные вершины к центру 0
		             		relativeCenter(bld);
		                    //преобразуем вершины
		                    verticesTransition(bld);
		                building = colladaObjects['landscape'][0]['children'][no].parent.children;
		                //**наполняем floor
		                var noFloor = 0
		                $.each(building, function(value){
		                    if (building[value].name.indexOf('floor') != -1){
		                        colladaObjects['landscape'][0].children[no].children.push(building[value].children[0]);
		                        colladaObjects['landscape'][0].children[no].children[noFloor].name = building[value].name;
		                        	flr = colladaObjects['landscape'][0].children[no].children[noFloor];
    			                    //добавляем свойство Z angle
		            		        setZangle(dae, flr);
		                            // ищем центр floor
		                            var bbox = new THREE.Box3().setFromObject(flr.parent);
		                            flr.BoxMin = bbox['min'];
		                            flr.BoxMax = bbox['max'];
		                            a = getCenter(bbox);
		                            flr.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                            //заполняем session['plans'] floors
		                    		session['plans'].push(fillSessionPlans(flr, 'floor'));
		                    		//заполняем session['plans_tree']
		                    		session['plans_tree'].push({'id': flr.id, 'idparent': flr.parent.parent.children[0].id});
		                            //приводим относительные вершины к центру 0 
                                   	relativeCenter(flr);
		                            // преобразуем вершины
		                            verticesTransition(flr);
		                            //для андрея высота и центр этажей
		                            flr.CenterZ = flr.BoxMin.z + Math.abs(flr.BoxMax.z - flr.BoxMin.z)/2;
		                            flr.HeightZ = Math.abs(flr.BoxMax.z - flr.BoxMin.z)
		                        //** наполняем kabinet и outer
		                        floor = colladaObjects['landscape'][0]['children'][no]['children'][noFloor].parent.children;
		                        var noKabinet = 0;
		                        $.each(floor, function(value){
		                            if(floor[value].name.indexOf('kabinet') != -1){
		                                colladaObjects['landscape'][0].children[no]['children'][noFloor].children.push(floor[value].children[0]);
		                                colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].name = floor[value].name;
		                                	kbnt = colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet];
    	    			                    //добавляем свойство Z angle
		            				        setZangle(dae, kbnt);
		            				        //обнуляем Z
		                    				clearZ(dae, kbnt, colladaObjects['landscape'][0]['Zangle']);
		                                    // ищем центр kabinet
		                                    var bbox = new THREE.Box3().setFromObject(kbnt.parent);
		                                    kbnt.BoxMin = bbox['min'];
		                                    kbnt.BoxMax = bbox['max'];
		                                    a = getCenter(bbox);
		                                    kbnt.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                                    //заполняем session['plans_tree']
		                    				session['plans_tree'].push({'id': kbnt.id, 'idparent': kbnt.parent.parent.children[0].id});
		                                    //заполняем session['plans'] kabinets
		                    				session['plans'].push(fillSessionPlans(kbnt, 'kabinet'));
		                                    //приводим относительные вершины к центру 0 
                                   			relativeCenter(kbnt);
		                                    // преобразуем вершины
		                                    verticesTransition(kbnt);
		                                //** наполняем wall
		                                kabinet = colladaObjects['landscape'][0]['children'][no]['children'][noFloor]['children'][noKabinet].parent.children;
		                                var noWall = 0;
		                                $.each(kabinet, function(value){
		                                    if(kabinet[value].name.indexOf('wall') != -1){
		                                        colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].children.push(kabinet[value].children[0]);
		                                        colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].children[noWall].name = kabinet[value].name
		                                            // ищем центр wall
		                                            wall = colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].children[noWall]
		                                            var bbox = new THREE.Box3().setFromObject(wall);
		                                            wall.BoxMin = bbox['min'];
		                                            wall.BoxMax = bbox['max'];
		                                            a = getCenter(bbox);
		                                            wall.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                                        noWall += 1;
		                                    }
		                                });
		                                noKabinet += 1;
		                            }
		                            if (floor[value].name.indexOf('outer') != -1){
		                                colladaObjects['landscape'][0].children[no]['children'][noFloor].children.push(floor[value].children[0]);
		                                colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].name = floor[value].name;
		                                    // ищем центр outer
		                                    outr = colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet];
		                                    var bbox = new THREE.Box3().setFromObject(outr);
		                                    outr.BoxMin = bbox['min'];
		                                    outr.BoxMax = bbox['max'];
		                                    a = getCenter(bbox);
		                                    outr.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                                noKabinet += 1
		                            }
		                        });
		                        noFloor += 1;
		                    }
		                });
		                no += 1;
		            }
		            // наполняем light
		            if (landscape.name.indexOf('light') != -1){
		                colladaObjects['landscape'][0].children.push(landscape.children[0]);
		                colladaObjects['landscape'][0]['children'][no]['name'] = colladaObjects['landscape'][0]['children'][no]['parent']['name'];
		                var light = colladaObjects['landscape'][0]['children'][no];
		                    // ищем центр light
		                    lght = colladaObjects['landscape'][0].children[no];
		                    var bbox = new THREE.Box3().setFromObject(lght);
		                    a = getCenter(bbox);
		                    lght.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                no += 1;
		            }
		        });

		//****************************
        //**настройки сцены по умолчанию
        //****************************
        //изменить материал для обектов
	    var setMaterialObject = function(obj, material) {
	    	obj.material = material;
		}
    	//landscape 
    	plane = colladaObjects['landscape'][0];
        /*plane.receiveShadow = true;*/
    	setMaterialObject(plane, new THREE.MeshBasicMaterial({ color: 0xdfe3ee}));
    	//building
        $.each(colladaObjects['landscape'][0].children, function(value){
            if (colladaObjects['landscape'][0].children[value].name.indexOf('building') != -1){
                building = colladaObjects['landscape'][0].children[value];
                bcolor = 0xffdbd;;
                building.visible = false;
                $.each(building.children, function(value){
                    //floor
                    floor = building.children[value];
                    setMaterialObject(floor, new THREE.MeshBasicMaterial({color: 0x8b9dc3, transparent:true}));
                    /*floor.receiveShadow = true;*/
                    /*floor.castShadow = true;*/
                    //kabinet n outer
                    $.each(floor.children, function(value){
                        if (floor.children[value].name.indexOf('outer') != -1){
                            outer = floor.children[value];
                            /*outer.castShadow = true;*/
                            setMaterialObject(outer, new THREE.MeshLambertMaterial({color: bcolor, transparent:true}));
                        } else if (floor.children[value].name.indexOf('kabinet') != -1){
                            kabinet = floor.children[value];
                            kcolor = 0x559e83;
                            kabinet.visible = false;
                            //wall
                            $.each(kabinet.children, function(value){
                                wall = kabinet.children[value];
                                /*wall.castShadow = true;*/
                                setMaterialObject(wall, new THREE.MeshLambertMaterial({color: kcolor, transparent:true}));
                            });
                        }
                    });
                });
            }
            if (colladaObjects['landscape'][0].children[value].name.indexOf('light') != -1){
                light = colladaObjects['landscape'][0].children[value];
                light.visible = false;
                a = light.Center;
                spotLight = new THREE.SpotLight(0xffffff);
                spotLight.castShadow = true;
                spotLight.position.set (a['x'], a['y'], a['z']);
                spotLight.target.position.set(a['x'], a['y'], a['z']{% if sceneop.light_target_symbol == 1 %}-{% else %}+{% endif%} 60);
                this.lightX = 20;
                this.lightY = 35;
                this.lightZ = 40;
                this.intensity = 5;
                this.decay = 8.5;   
                this.distance = 87;
                this.angle = 0.54;
                this.exponent = 0;
                this.shadowCameraNear = 10;
                this.shadowCameraFar = 100;
                this.shadowCameraFov = 50;
                this.shadowCameraVisible=false;
                this.shadowMapWidth=1028;
                this.shadowMapHeight=1028;
                this.shadowBias=0;
                this.shadowDarkness=0.5;
                spotLight.target.updateMatrixWorld();
                scene.add(spotLight);
            }
        });

				//разворот сцены dae
				z = Math.PI;
				x = Math.PI;
				y = Math.PI;

		    	dae.rotation.z = z;
		    	dae.rotation.x = x;
		    	dae.rotation.y = y;

		    	sceneOptions['DaeRotation'] = {};
		    	sceneOptions['DaeRotation'].x = x;
		    	sceneOptions['DaeRotation'].y = y;
		    	sceneOptions['DaeRotation'].z = z;


		    	var angleZ = dae.rotation.z;
		    	var angleX = dae.rotation.x;
		    	var angleY = dae.rotation.y;

		    	var bbox = new THREE.Box3().setFromObject(dae);

		    	//получаем новый центр объектов
		    	//building
		    	newCenter(dae.children[0], 'building');
		    	//floor
		    	newCenter(dae.children[0], 'floor');
		    	//kabinet
		    	newCenter(dae.children[0], 'kabinet');

		    	//bbox helper func
		    	function helper(object){
		    		var bbox = new THREE.Box3().setFromObject(object);
		    		var hex = 0xff0000;
                    var bbox = new THREE.BoundingBoxHelper(object, hex);
                    bbox.update();
                    scene.add(bbox);
		    	}
		    	//bbox object and adding property CenterNew
		    	function newCenter(dae, text){
		    		if(dae.children){
		    			for (var i = 1; i < dae.children.length; i++){
		    				if(dae.children[i].name.indexOf(text) != -1){
		    					object = dae.children[i].children[0];
		    					bbox = new THREE.Box3().setFromObject(object.parent);
	                            a = getCenter(bbox);
			                    object.CenterNew = new THREE.Vector3(a['x'], a['y'], a['z']);
			                    object.BoxMin = bbox['min'];
                                object.BoxMax = bbox['max'];
			                    /*helper(object.parent);*/
		    				}
		    				newCenter(dae.children[i], text);
		    			}
		    		}
		    	}

		    	// rotate all vertices at dae position
		    	toDaePosition(dae.children[0], 'building', angleZ, angleX, angleY);

		    	toDaePosition(dae.children[0], 'floor', angleZ, angleX, angleY);

		    	toDaePosition(dae.children[0], 'kabinet', angleZ, angleX, angleY);

		    	// функция разворота вершин kabinet, если есть поворот по z
		    	function rotateObjectVertices(dae, objectType){
		    		if (dae.children){
		    			for(var i=0; i < dae.children.length; i++){
		    				if (dae.children[i].name.indexOf(objectType) != -1 && dae.children[i].Zangle != 0){
		    					angleZ = dae.children[i].Zangle;
		    					name = dae.children[i].name;
		    					$.each(dae.children[i].Geometry, function(index){
									//z
									object = dae.children[i];
		    						x = object.Geometry[index]['x'];
		    						y = object.Geometry[index]['y'];
									x2 = r(x, y, angleZ, 'x');
									y2 = r(x, y, angleZ, 'y');
		    						object.Geometry[index]['x'] = x2;
		    						object.Geometry[index]['y'] = y2;
		    					});
		    				}
		    				rotateObjectVertices(dae.children[i], objectType);
		    			}
		    		}
		    	}

		    	function toDaePosition(dae, text, angleZ, angleX, angleY){
		    		if(dae.children){
		    			for (var i=1; i < dae.children.length; i++){
		    				if(dae.children[i].name.indexOf(text)!= -1){
		    					object = dae.children[i].children[0];
		    					//разворачиваем все vertices
		    					$.each(object.Geometry, function(index){
									//z
		    						x = object.Geometry[index]['x'];
		    						y = object.Geometry[index]['y'];
									x2 = r(x, y, angleZ, 'x');
									y2 = r(x, y, angleZ, 'y');
									//x
									x2 = rz(x2, 0, angleX, 'x');
									//y
									y2 = rz2(y2, 0, angleY, 'y');
		    						object.Geometry[index]['x'] = x2;
		    						object.Geometry[index]['y'] = y2;
		    					});
		    				}
		    				toDaePosition(dae.children[i], text, angleZ, angleX, angleY);
		    			}
		    		}
		    	}

		    	// rotate all vertices at zAngle if building have zAngle property
		    	rotateAsBuilding(dae.children[0], angleX, angleY);
		    	function rotateAsBuilding(dae){
		    		if (dae.children){
		    			for (var i=1; i < dae.children.length; i++){
		    				if (dae.children[i].name.indexOf('building')!= -1 && dae.children[i].Zangle != 0){
		    					Zangle = dae.children[i].children[0].Zangle + colladaObjects['landscape'][0]['Zangle'];
		    					if ((angleX == Math.PI && angleY == Math.PI) || (angleX == -Math.PI && angleY == -Math.PI) || (angleX == 0 && angleY == 0)){
		    						rotateChild(dae.children[i], -Zangle);	
		    					} else {
		    						rotateChild(dae.children[i], Zangle);	
		    					}
		    				}
		    				rotateAsBuilding(dae.children[i]);
		    			}
		    		}
		    	}

		    	function rotateChild(node, Zangle){
		    		if (node.name.indexOf('building') != -1){
		    			//ищем центр building, для этого создаем plane
		    			var planeGeometry = new THREE.Geometry();		
		    			$.each(node.children[0].Geometry, function(index){
		    				//z
    						x = node.children[0].Geometry[index]['x'];
    						y = node.children[0].Geometry[index]['y'];
							x2 = r(x, y, Zangle, 'x');
							y2 = r(x, y, Zangle, 'y');
							node.children[0].Geometry[index]['x'] = x2;
							node.children[0].Geometry[index]['y'] = y2;

							planeGeometry.vertices.push(
								new THREE.Vector3(x2, y2)
							)
		    			});
		    			$.each(node.children[0].geometry.faces, function(index){
	    					a = node.children[0].geometry.faces[index].a;
	    					b = node.children[0].geometry.faces[index].b;
	    					c = node.children[0].geometry.faces[index].c;
		    				planeGeometry.faces.push(
		    					new THREE.Face3(a, b, c)			
		    				)
		    			});

		    			planeGeometry.computeBoundingSphere();
		    			var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide});
						var p = new THREE.Mesh(planeGeometry, planeMaterial);
						var bbox = new THREE.Box3().setFromObject(p);
						a = getCenter(bbox);
                        node.children[0].Center = new THREE.Vector3(a['x'], a['y'], a['z']);
						scene.add(p);
						scene.remove(p);
		    		}
		    		if (node.children){
		    			for (var i=1; i < node.children.length; i++){
		    				if (node.children[i].children[0].Geometry){
		    					//ищем центр floor, kabinet, для этого создаем plane
		    					var planeGeometry = new THREE.Geometry();
		    					object = node.children[i].children[0];
		    					$.each(object.Geometry, function(index){
		    						//z
		    						x = object.Geometry[index]['x'];
		    						y = object.Geometry[index]['y'];
									x2 = r(x, y, Zangle, 'x');
									y2 = r(x, y, Zangle, 'y');
									object.Geometry[index]['x'] = x2;
									object.Geometry[index]['y'] = y2;

									planeGeometry.vertices.push(
										new THREE.Vector3(x2, y2)
									)
		    					});
				    			$.each(object.geometry.faces, function(index){
									a = object.geometry.faces[index].a;
	    							b = object.geometry.faces[index].b;
	    							c = object.geometry.faces[index].c;
				    				planeGeometry.faces.push(
				    					new THREE.Face3(a, b, c)			
				    				)
		    					});

		    					planeGeometry.computeBoundingSphere();
		    					var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide});
								var p = new THREE.Mesh(planeGeometry, planeMaterial);
								var bbox = new THREE.Box3().setFromObject(p);
								a = getCenter(bbox);
                        		object.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
								scene.add(p);
								scene.remove(p);
		    				}
		    				rotateChild(node.children[i], Zangle);
		    			}
		    		}
		    	}

		    	//Найти offset между Center и CenterNew
		    	offset(dae.children[0]);
		    	function offset(dae){
		    		if (dae.children){
		    			for(var i=0; i < dae.children.length; i++){
		    				if (dae.children[i].Center != undefined && dae.children[i].CenterNew != undefined){
		    					Center = dae.children[i].Center;
		    					CenterNew = dae.children[i].CenterNew;
		    					dae.children[i].Offset = {};
		    					//ищем offset в абсолютной величине
		    					dae.children[i].Offset['x'] = Math.abs(Center['x'] - CenterNew['x']);
		    					dae.children[i].Offset['y'] = Math.abs(Center['y'] - CenterNew['y']);
		    					Offset = dae.children[i].Offset;
		    					//определяем знак для offset
		    					if (CenterNew['x'] + Offset['x'] == Center['x']){

		    					} else if (CenterNew['x'] - Offset['x'] == Center['x']){
		    						Offset['x'] = - Offset['x'];
		    					}

		    					if (CenterNew['y'] + Offset['y'] == Center['y']){

		    					} else if (CenterNew['y'] - Offset['y'] == Center['y']){
		    						Offset['y'] = - Offset['y']
		    					}
		    				}
	    				offset(dae.children[i]);
		    			}
		    		}
		    	}

		    	//Смещаем вершины на значение Offset
		    	addOffsetToVertices(colladaObjects['landscape'][0], 0);
		    	function addOffsetToVertices(dae){
		    		if(dae.children){
		    			for (var i=0; i < dae.children.length; i++){
		    				if (dae.children[i].Offset != undefined && dae.children[i].colladaId == undefined){
		    					Geometry = dae.children[i].Geometry;
		    					Offset = dae.children[i].Offset;
		    					$.each(Geometry, function(index){

	    							if (dae.children[i].Center['x'] > 0 && Offset['x'] > 0) {
		    							Geometry[index]['x'] = Geometry[index]['x'] - Offset['x'];
	    							} else if (dae.children[i].Center['x'] < 0 && Offset['x'] > 0){
	    								Geometry[index]['x'] = Geometry[index]['x'] + Offset['x'];
	    							} else {
	    								Geometry[index]['x'] = Geometry[index]['x'] - Offset['x'];
	    							}

	    							if (dae.children[i].Center['y'] > 0 && Offset['y'] > 0) {
		    							Geometry[index]['y'] = Geometry[index]['y'] - Offset['y'];
	    							} else if (dae.children[i].Center['y'] < 0 && Offset['y'] > 0){
	    								Geometry[index]['y'] = Geometry[index]['y'] + Offset['y'];
	    							} else {
	    								Geometry[index]['y'] = Geometry[index]['y'] - Offset['y'];
	    							}

		    					});
		    				}
		    				addOffsetToVertices(dae.children[i]);
		    			}
		    		}
		    	}

		    	//поворачиваем kabinet на Zangle
		    	rotateBuilding(colladaObjects['landscape'][0], 'kabinet');
		    	//поворачиваем вершины kabinet на Zangle
		    	rotateObjectVertices(colladaObjects['landscape'][0], 'kabinet');

		    	//поворачиваем building на Zangle
		    	rotateBuilding(colladaObjects['landscape'][0], 'building');
		    	function rotateBuilding(dae, objectType){
		    		if(dae.children){
		    			for(var i = 0; i < dae.children.length; i++){
		    				if (dae.children[i].name.indexOf(objectType)!= -1 && dae.children[i].Zangle != undefined){
		    					Zangle = dae.children[i].Zangle;
		    					building = dae.children[i].parent;
		    					building.rotation.z = Zangle;
		    				}
		    				rotateBuilding(dae.children[i], objectType);
		    			}
		    		}
		    	}

		    	//получаем новый центр объектов
		    	//building
		    	newCenter(dae.children[0], 'building');
		    	//floor
		    	newCenter(dae.children[0], 'floor');
		    	//kabinet
		    	newCenter(dae.children[0], 'kabinet');

		    	//ищем центр повернутых фигур
		    	rotateChild(dae.children[0], 0);
		    	//ищем offset
		    	offset(dae.children[0]);
		    	//ещё раз смещаем вершины Geometry
		    	addOffsetToVertices(colladaObjects['landscape'][0], 0);



		    	//наполняем словарь вершин BoxMin BoxMax
		    	fillVerticesDict(colladaObjects['landscape'][0]);
		    	function fillVerticesDict(dae){
		    		if(dae.children){
		    			for(var i = 0; i<dae.children.length; i++){
		    				if (dae.children[i].BoxMin != undefined && dae.children[i].BoxMax != undefined && dae.children[i].name.indexOf('outer') == -1 && dae.children[i].name.indexOf('wall') == -1){
		    					object = dae.children[i];
		    					verticesDict['element'].push({'name':object.name, 'vertices': object.Geometry, 'BoxMin': object.BoxMin, 'BoxMax': object.BoxMax});
		    				}
		    				fillVerticesDict(dae.children[i]);
		    			}
		    		}
		    	}
		    	//записываем результат в БД
				/*$.ajax({
					type:"POST",
					url:"/landscape_save",
        			data: JSON.stringify({'landscape_id': '{{landscape_id}}'.toString(), colladaObjects, verticesDict, sceneOptions}),
       				contentType: "application/json; charset=utf-8",
		            dataType: 'json',
		          	async: true,
		          	success: function(data, textStatus, jqXHR){
		          		window.location = '/landscapeloadform/success';
		          		console.log(data);
		          	}
				});*/

				//ищу floor
	    		var floorVert = [];
	    		var floorFaces = [];
				var floor_003 = [];
		        lookColladaId(dae, 'kabinet_000', floor_003);
		        function lookColladaId(dae, text, array){
		        	if (dae.children){
		        		for (var i = 0; i < dae.children.length; i++){
		        			if (dae.children[i].colladaId == text){
		        				array.push(dae.children[i]);
		        				return true
		        			}
		        			lookColladaId(dae.children[i], text, array);
		        		}
		        	}
		        }

		    	$.each(floor_003[0].children[0].Geometry, function(index){
					value = floor_003[0].children[0].Geometry[index];
					floorVert.push({'x': value['x'], 'y': value['y']});
				});

				$.each(floor_003[0].children[0].geometry.faces, function(index){
					value = floor_003[0].children[0].geometry.faces[index];
					floorFaces.push({'a': value['a'], 'b': value['b'], 'c': value['c']});
				});

				//проверить плоскость правильно ли отображается
				var planeGeometry = new THREE.Geometry();
				$.each(floorVert, function(index){
					x = floorVert[index]['x'];
					y = floorVert[index]['y'];
					planeGeometry.vertices.push(
						new THREE.Vector3(x, y, 5)
					)
				});
				$.each(floorFaces, function(index){
					a = floorFaces[index]['a'];
					b = floorFaces[index]['b'];
					c = floorFaces[index]['c'];
					planeGeometry.faces.push(
						new THREE.Face3(a, b, c)
					)
				});

				planeGeometry.computeBoundingSphere();

				var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide});
				var p = new THREE.Mesh(planeGeometry, planeMaterial);
				/*helper(p);*/
				/*p.rotation.set(0, 0, -0.872, 'XYZ');*/
				scene.add(p);

		    	// helper sphere
		    	/*geometry = new THREE.SphereGeometry(2, 32, 32);
		    	material = new THREE.MeshBasicMaterial({color: 0xbbbbbb});
		    	var sph = new THREE.Mesh(geometry, material);
		    	sph.position.set(0, 28.11, 0);
		    	scene.add(sph);*/
		    });
			//фунцкция преобразования вершин отдельных объектов из относительных в абсолютные(dae файл - upaxis - down)
			function verticesTransition(object){
				var xmin = 0;
	           	var xmax = 0;
	           	var ymin = 0;
	           	var ymax = 0;
	           	object.Geometry = [];
	            $.each(object.geometry.relativeVertices, function(index){
	            	object.Geometry.push({'x': 0, 'y': 0});
	            	if (xmin == 0){
	            		xmin = object.geometry.relativeVertices[index].x;
	            	} else if (object.geometry.relativeVertices[index].x < xmin){
	            		xmin = object.geometry.relativeVertices[index].x;
	            	}
	            	if (xmax == 0){
	            		xmax = object.geometry.relativeVertices[index].x;
	            	} else if (object.geometry.relativeVertices[index].x > xmax){
	            		xmax = object.geometry.relativeVertices[index].x;
	            	}

	            	if (ymin == 0){
	            		ymin = object.geometry.relativeVertices[index].y;
	            	} else if (object.geometry.relativeVertices[index] < ymin){
	            		ymin = object.geometry.relativeVertices[index].y;
	            	}
	            	if (ymax == 0){
	            		ymax = object.geometry.relativeVertices[index].y;
	            	} else if (object.geometry.relativeVertices[index].y > ymax){
	            		ymax = object.geometry.relativeVertices[index].y;
	            	}
	            });
				$.each(object.geometry.relativeVertices, function(index){
					x = object.geometry.relativeVertices[index].x;
					y = object.geometry.relativeVertices[index].y;
					if (x == xmin){
						object.Geometry[index].x = object.BoxMin.x;
					}
					if (x == xmax){
						object.Geometry[index].x = object.BoxMax.x;
					}
					if (y == ymin){
						object.Geometry[index].y = object.BoxMin.y;
					}
					if (y == ymax){
						object.Geometry[index].y = object.BoxMax.y;
					}
					//если y отрицательное число
					if (y != ymin && y < 0){
						yDistanse = Math.abs(object.BoxMin.y - object.BoxMax.y)/2;
						//ищем коэфициент
						relY = object.geometry.relativeVertices[index].y;
						relminY = object.geometry.relativeMin.y;
						k = Math.abs(relY/relminY);
						object.Geometry[index].y = object.Center.y - yDistanse*k;
					}
					//ecли у положительное число
					if (y != ymax && y > 0){
						yDistanse = Math.abs(object.BoxMin.y - object.BoxMax.y)/2;
						//ищем коэфициент
						relY = object.geometry.relativeVertices[index].y;
						relmaxY = object.geometry.relativeMax.y;
						k = Math.abs(relY/relmaxY);
						object.Geometry[index].y = object.Center.y + yDistanse*k;
					}
					//если x отрицательное число
					if (x != xmin && x < 0){
						xDistanse = Math.abs(object.BoxMin.x - object.BoxMax.x)/2;
						//ищем коэфициент
						relX = object.geometry.relativeVertices[index].x;
						relminX = object.geometry.relativeMin.x;
						k = Math.abs(relX/relminX);
						object.Geometry[index].x = object.Center.x - xDistanse*k;
					}
					//если x положительное число
					if (x != xmax && x > 0){
						xDistanse = Math.abs(object.BoxMin.x - object.BoxMax.x)/2;
						//ищем коэфициент
						relX = object.geometry.relativeVertices[index].x;
						relmaxX = object.geometry.relativeMax.x;
						k = Math.abs(relX/relmaxX);
						object.Geometry[index].x = object.Center.x + xDistanse*k;
					}
				});
				//меняем "x" на "y"
				/*$.each(object.Geometry, function(index){
					x = object.Geometry[index].x;
					y = object.Geometry[index].y;
					object.Geometry[index].x = y;
					object.Geometry[index].y = x;
				});*/
			}
			function rz2(y, z, gradus, returning){
				y2 = y * Math.cos(gradus) + z * Math.sin(gradus);
				if (returning == 'y'){
					return y2;
				}
			}

			function rz(x, z, gradus, returning){
				x2 = x * Math.cos(gradus) + z * Math.sin(gradus);
				if (returning == 'x'){
					return x2;
				}
			}

			function r(x, y, gradus, returning){
				/*gradus = gradus * Math.PI/180;*/
				x2 = x * Math.cos(gradus) + y * Math.sin(gradus);
				y2 = -x * Math.sin(gradus) + y * Math.cos(gradus);
				if (returning == 'x'){
					return x2
				} else if(returning == 'y') {
					return y2
				}
			}


			/* позиция камеры по умолчанию */
		    /*camera.position.set(69, 69, -50);*/
		    x = 70;
		    y = -80;
		    z = 50;
		    camera.position.set(x, y, z);
		    sceneOptions['CameraPosition'] = {};
		    sceneOptions['CameraPosition'].x = x;
		    sceneOptions['CameraPosition'].y = y;
		    sceneOptions['CameraPosition'].z = z;
		    /* вверх - это Z*/
		    /*camera.up.set( 0, 0, -1 );*/
		    x = 0;
		    y = 0;
		    z = 1;
		    if (z == 1){
		    	sceneOptions['LightTargetSymbol'] = 1;
		    	sceneOptions['CircleStepSymbol'] = 1;
		    	sceneOptions['GetWallHeightSymbol'] = 1; 
		    } else if (z == -1){
		    	sceneOptions['LightTargetSymbol'] = 0;
		    	sceneOptions['CircleStepSymbol'] = 0;
		    	sceneOptions['GetWallHeightSymbol'] = 0;
		    }
		    camera.up.set(x, y, z);
		    sceneOptions['CameraUp'] = {};
		    sceneOptions['CameraUp'].x = x;
		    sceneOptions['CameraUp'].y = y;
		    sceneOptions['CameraUp'].z = z;

		    scene.add(camera);


		    /*камера. контроль за сменой позиции*/
		    controls = new THREE.OrbitControls( camera, renderer.domElement );
		    /* камера вращается вокруг данных координат*/
		    x = 67;
		    y = 40;
		    z = 0;
		    sceneOptions['ControlsTarget'] = {};
		    sceneOptions['ControlsTarget'].x = x;
		    sceneOptions['ControlsTarget'].y = y;
		    sceneOptions['ControlsTarget'].z = z;
		    controls.target.copy(new THREE.Vector3(x, y, z));
		    //камера смотрит
		    camera.lookAt(new THREE.Vector3(x, y, z));
		    controls.addEventListener( 'change', render );
		    hemi = new THREE.HemisphereLight(0xbbbbbb, 0x0099FF);
		    scene.add(hemi);

		    $("#webGL-container").append(renderer.domElement);

		    /*статистика*/
		    stats = new Stats();        
		    stats.domElement.style.position = 'absolute';
		    stats.domElement.style.left = '0px';
		    stats.domElement.style.top = '0px';     
		    $("#webGL-container").append( stats.domElement );
	    }

	    function render(){
	    }

	    function update(){
    	}

	    function animate(){
        requestAnimationFrame(animate);
        render();
        update();
        stats.update();     
        renderer.render(scene, camera);
	    }

	    init();
  	  animate();


	    $(window).resize(function(){
	        SCREEN_WIDTH = window.innerWidth;
	        SCREEN_HEIGHT = window.innerHeight;
	        camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
	        camera.updateProjectionMatrix();
	        renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
	    });
	</script>
    <script src="{% static 'js/jscolor.min.js'%}"></script>
    <script src="{% static 'js/foundation.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.reveal.js' %}"></script>
    <script src="{% static 'js/vendor/what-input.min.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.slider.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.tabs.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.keyboard.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.timerAndImageLoader.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.drilldown.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.motion.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.nest.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.mediaQuery.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.accordionMenu.js' %}"></script>
    <script>
        $(document).foundation();
        $('.is-drilldown').css('max-height', '300px');
    </script>
	</body>
</html>