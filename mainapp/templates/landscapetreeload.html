<!DOCTYPE HTML>

<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Our WebGl</title>
		{% load staticfiles %}

		<script type="text/javascript" src="{% static 'js/vendor/jquery.min.js' %}"></script>
        <script type="text/javascript" src="{% static 'js/vendor/foundation.core.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/three.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/dat.gui.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/OrbitControls.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/stats.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/helvetiker_regular.typeface.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/ColladaLoader.js' %}"></script>


  		<link rel="stylesheet" href="{% static 'css/foundation.css' %}">
    	<link rel="stylesheet" href="{% static 'css/app.css' %}">


		<style>
			body{
				margin:0;
				overflow:hidden;
			}
		</style>
	</head>
	<body>
		{% csrf_token %}
		<!-- ***блок 3д изображения*** -->
		<!--************************-->
		<div id ="webGL-container"></div>
    <!-- ***блок панель управления*** -->
    <!--************************-->
    <script>
	    var colladaObjects = {};

	    function init(){
	    	/*сцена, камера */
		    scene = new THREE.Scene();
		    camera =  new THREE.PerspectiveCamera(85, window.innerWidth/window.innerHeight, .1, 1000);
		    renderer = new THREE.WebGLRenderer({antialias:true});
		    
		    /*рендерер;*/
		    renderer.setSize(window.innerWidth, window.innerHeight);
		    renderer.shadowMapEnabled= true;
		    renderer.shadowMapType = THREE.PCFSoftShadowMap;
		    
		    /*оси*/
		    axis = new THREE.AxisHelper(30);
		    scene.add(axis);

		    /* сетка */
		    grid = new THREE.GridHelper(100, 25);
		    color = new THREE.Color("rgb(255, 0, 0)");
		    grid.setColors(color, 0x000000);
		    grid.rotation.x = -0.5* Math.PI
		    /*scene.add(grid);*/

		    /* add collada import */
    		var loader = new THREE.ColladaLoader();
    		/*loader.options.convertUpAxis = true;*/

        	//**словарь настроек сцены (Camera up value, Camera position value, dae rotation z, x, y, light target position positive/negative, Cylinder positiven negative)
	        sceneOptions = {};

	        //маркеры калибровки
		    var markGeom = new THREE.BoxGeometry(0.5, 0.5, 0.5, 2, 2, 2);
		    var markMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
		    this.marker6004 = new THREE.Mesh(markGeom, markMaterial);
		    marker6004.position.set(76.457, 39.682, 7.6);
		    scene.add(marker6004);

		    this.marker6042 = new THREE.Mesh(markGeom, markMaterial);
		    marker6042.position.set(67.725, 39.850, 7.6);
		    scene.add(marker6042);

		    this.marker6003 = new THREE.Mesh(markGeom, markMaterial);
		    marker6003.position.set(59.531, 39.811 , 7.6);
		    scene.add(marker6003);

		    this.marker6045 = new THREE.Mesh(markGeom, markMaterial);
		    marker6045.position.set(76.426, 30.141, 8.7);
		    scene.add(marker6045);

		    loader.load( '/static/js/webgl/models/{{source}}', function ( collada ) {
				loader.options.convertUpAxis = true;

		        //функция поиска центра collada объекта на оси координат
		        var getCenter = function(obj){
		            minx = obj.min.x;
		            miny = obj.min.y;
		            minz = obj.min.z;

		            maxx = obj.max.x;
		            maxy = obj.max.y;
		            maxz = obj.max.z;

		            x = (minx - maxx);
		            x = x - 2*x;

		            y = (miny - maxy);
		            y = y - 2*y;

		            z = (minz - maxz);
		            z = z - 2*z;

		            a = {}
		            a['x'] = minx + x/2;
		            a['y'] = miny + y/2;
		            a['z'] = minz + z/2;
		            return a;
		        }

		        //функция поиска угла поворота building по оси Z объекта
		       	function setZangle(dae, object){
		       		if (dae.children){
		       			for (var i = 0; i < dae.children.length; i ++){
		       				if(dae.children[i].colladaId == object.name){
		       					z = dae.children[i].rotation.z;
		       					object.Zangle = z;
		       					return false;
		       				} 
		       				setZangle(dae.children[i], object);
		       			}
		       		}
		       	}

		       	//функция обнуления Z у building
		       	function clearZ(dae, object, Zangle){
		       		if (dae.children){
		       			for (var i = 0; i < dae.children.length; i++){
		       				if(dae.children[i].colladaId == object.name){
		       					dae.children[i].rotation.z = 0 - Zangle;
		       					return false;
		       				}
		       				clearZ(dae.children[i], object, Zangle);
		       			}
		       		}
		       	}

		    	//gls.dae
		    	var dae = collada.scene;
		    	/*dae.position.set(28.141,59.087,8.6);*/
		    	x = 59;
		    	y = 28;
		    	z = 6;
		    	dae.position.set(x, y, z);
		    	sceneOptions['DaePosition'] = {};
		    	sceneOptions['DaePosition'].x = x;
		    	sceneOptions['DaePosition'].y = y;
		    	sceneOptions['DaePosition'].z = z;
		    	dae.scale.set(1,1,1);
		    	scene.add(dae);


		        //****************************
		        //**заполняем массив элементов сцены
		        //****************************

		        //**дерево
		        colladaObjects['landscape'] = [];

		        //**вершины
		        verticesDict = {};
		        verticesDict['element'] = [];

		        //**наполняем landscape
		        colladaObjects['landscape'].push(dae['children'][0]['children'][0]);
		        colladaObjects['landscape'][0].name = colladaObjects['landscape'][0]['parent']['name'];
		            // ищем центр landscape
		            lndscp = dae;
		            var bbox = new THREE.Box3().setFromObject(lndscp);
		            landscape = colladaObjects['landscape'][0];
		            a = getCenter(bbox);
		            landscape.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		            //добавляем свойство Z angle
		            setZangle(dae, landscape);
		        //**наполняем building
		        var no = 0;
		        $.each(colladaObjects['landscape'][0].parent.children, function(value){
		            var landscape = colladaObjects['landscape'][0].parent.children[value];
		            if (landscape.name.indexOf('building') != -1){
		                colladaObjects['landscape'][0].children.push(landscape.children[0]);
		                colladaObjects['landscape'][0]['children'][no]['name'] = colladaObjects['landscape'][0]['children'][no]['parent']['name'];
		                	bld = colladaObjects['landscape'][0].children[no];
		                    //добавляем свойство Z angle
		                    setZangle(dae, bld);
		                    //обнуляем Z
		                    clearZ(dae, bld, colladaObjects['landscape'][0]['Zangle']);
		                    // ищем центр building
		                    var bbox = new THREE.Box3().setFromObject(bld.parent);
		                    bld.BoxMin = bbox['min'];
		                    bld.BoxMax = bbox['max'];
		                    a = getCenter(bbox);
		                    bld.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                    //преобразуем вершины
		                    verticesTransition(bld);
		                    //наполняем vertices
		                    /*verticesDict['element'].push({'name': bld.name, 'vertices': bld.Geometry, 'BoxMin': bld.BoxMin, 'BoxMax': bld.BoxMax});*/
		                building = colladaObjects['landscape'][0]['children'][no].parent.children;
		                //**наполняем floor
		                var noFloor = 0
		                $.each(building, function(value){
		                    if (building[value].name.indexOf('floor') != -1){
		                        colladaObjects['landscape'][0].children[no].children.push(building[value].children[0]);
		                        colladaObjects['landscape'][0].children[no].children[noFloor].name = building[value].name;
		                            // ищем центр floor
		                            flr = colladaObjects['landscape'][0].children[no].children[noFloor];
		                            var bbox = new THREE.Box3().setFromObject(flr.parent);
		                            flr.BoxMin = bbox['min'];
		                            flr.BoxMax = bbox['max'];
		                            a = getCenter(bbox);
		                            flr.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                            // преобразуем вершины
		                            verticesTransition(flr);
		                            // наполняем vertices
		                            /*verticesDict['element'].push({'name':flr.name, 'vertices': flr.Geometry, 'BoxMin': flr.BoxMin, 'BoxMax': flr.BoxMax});*/
		                        //** наполняем kabinet и outer
		                        floor = colladaObjects['landscape'][0]['children'][no]['children'][noFloor].parent.children;
		                        var noKabinet = 0;
		                        $.each(floor, function(value){
		                            if(floor[value].name.indexOf('kabinet') != -1){
		                                colladaObjects['landscape'][0].children[no]['children'][noFloor].children.push(floor[value].children[0]);
		                                colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].name = floor[value].name;
		                                    // ищем центр kabinet
		                                    kbnt = colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet];
		                                    var bbox = new THREE.Box3().setFromObject(kbnt.parent);
		                                    kbnt.BoxMin = bbox['min'];
		                                    kbnt.BoxMax = bbox['max'];
		                                    a = getCenter(bbox);
		                                    kbnt.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                                    // преобразуем вершины
		                                    verticesTransition(kbnt);
		                                    // наполняем vertices
		                                    /*verticesDict['element'].push({'name':kbnt.name, 'vertices': kbnt.Geometry, 'BoxMin': kbnt.BoxMin, 'BoxMax': kbnt.BoxMax});*/
		                                //** наполняем wall
		                                kabinet = colladaObjects['landscape'][0]['children'][no]['children'][noFloor]['children'][noKabinet].parent.children;
		                                var noWall = 0;
		                                $.each(kabinet, function(value){
		                                    if(kabinet[value].name.indexOf('wall') != -1){
		                                        colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].children.push(kabinet[value].children[0]);
		                                        colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].children[noWall].name = kabinet[value].name
		                                            // ищем центр wall
		                                            wall = colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].children[noWall]
		                                            var bbox = new THREE.Box3().setFromObject(wall);
		                                            wall.BoxMin = bbox['min'];
		                                            wall.BoxMax = bbox['max'];
		                                            a = getCenter(bbox);
		                                            wall.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                                        noWall += 1;
		                                    }
		                                });
		                                noKabinet += 1;
		                            }
		                            if (floor[value].name.indexOf('outer') != -1){
		                                colladaObjects['landscape'][0].children[no]['children'][noFloor].children.push(floor[value].children[0]);
		                                colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet].name = floor[value].name;
		                                    // ищем центр outer
		                                    outr = colladaObjects['landscape'][0].children[no]['children'][noFloor].children[noKabinet];
		                                    var bbox = new THREE.Box3().setFromObject(outr);
		                                    outr.BoxMin = bbox['min'];
		                                    outr.BoxMax = bbox['max'];
		                                    a = getCenter(bbox);
		                                    outr.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                                noKabinet += 1
		                            }
		                        });
		                        noFloor += 1;
		                    }
		                });
		                no += 1;
		            }
		            // наполняем light
		            if (landscape.name.indexOf('light') != -1){
		                colladaObjects['landscape'][0].children.push(landscape.children[0]);
		                colladaObjects['landscape'][0]['children'][no]['name'] = colladaObjects['landscape'][0]['children'][no]['parent']['name'];
		                var light = colladaObjects['landscape'][0]['children'][no];
		                    // ищем центр light
		                    lght = colladaObjects['landscape'][0].children[no];
		                    var bbox = new THREE.Box3().setFromObject(lght);
		                    a = getCenter(bbox);
		                    lght.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
		                no += 1;
		            }
		        });

				//разворот сцены dae
				z = Math.PI;
				x = Math.PI;
				y = Math.PI;

		    	dae.rotation.z = z;
		    	dae.rotation.x = x;
		    	dae.rotation.y = y;

		    	sceneOptions['DaeRotation'] = {};
		    	sceneOptions['DaeRotation'].x = x;
		    	sceneOptions['DaeRotation'].y = y;
		    	sceneOptions['DaeRotation'].z = z;


		    	var angleZ = dae.rotation.z;
		    	var angleX = dae.rotation.x;
		    	var angleY = dae.rotation.y;

		    	var bbox = new THREE.Box3().setFromObject(dae);

		    	//получаем новый центр объектов
		    	//building
		    	newCenter(dae.children[0], 'building');
		    	//floor
		    	newCenter(dae.children[0], 'floor');
		    	//kabinet
		    	newCenter(dae.children[0], 'kabinet');

		    	//bbox helper func
		    	function helper(object){
		    		var bbox = new THREE.Box3().setFromObject(object);
		    		var hex = 0xff0000;
                    var bbox = new THREE.BoundingBoxHelper(object, hex);
                    bbox.update();
                    scene.add(bbox);
		    	}
		    	//bbox object and adding property CenterNew
		    	function newCenter(dae, text){
		    		if(dae.children){
		    			for (var i = 1; i < dae.children.length; i++){
		    				if(dae.children[i].name.indexOf(text) != -1){
		    					object = dae.children[i].children[0];
		    					bbox = new THREE.Box3().setFromObject(object.parent);
	                            a = getCenter(bbox);
			                    object.CenterNew = new THREE.Vector3(a['x'], a['y'], a['z']);
			                    object.BoxMin = bbox['min'];
                                object.BoxMax = bbox['max'];
			                    /*helper(object.parent);*/
		    				}
		    				newCenter(dae.children[i], text);
		    			}
		    		}
		    	}

		    	// rotate all vertices at dae position
		    	toDaePosition(dae.children[0], 'building', angleZ, angleX, angleY);

		    	toDaePosition(dae.children[0], 'floor', angleZ, angleX, angleY);

		    	toDaePosition(dae.children[0], 'kabinet', angleZ, angleX, angleY);

		    	function toDaePosition(dae, text, angleZ, angleX, angleY){
		    		if(dae.children){
		    			for (var i=1; i < dae.children.length; i++){
		    				if(dae.children[i].name.indexOf(text)!= -1){
		    					object = dae.children[i].children[0];
		    					//разворачиваем все vertices
		    					$.each(object.Geometry, function(index){
									//z
		    						x = object.Geometry[index]['x'];
		    						y = object.Geometry[index]['y'];
									x2 = r(x, y, angleZ, 'x');
									y2 = r(x, y, angleZ, 'y');
									//x
									x2 = rz(x2, 0, angleX, 'x');
									//y
									y2 = rz2(y2, 0, angleY, 'y');
		    						object.Geometry[index]['x'] = x2;
		    						object.Geometry[index]['y'] = y2;
		    					});
		    				}
		    				toDaePosition(dae.children[i], text, angleZ, angleX, angleY);
		    			}
		    		}
		    	}

		    	// rotate all vertices at zAngle if building have zAngle property
		    	rotateAsBuilding(dae.children[0], angleX, angleY);
		    	function rotateAsBuilding(dae){
		    		if (dae.children){
		    			for (var i=1; i < dae.children.length; i++){
		    				if (dae.children[i].name.indexOf('building')!= -1 && dae.children[i].Zangle != 0){
		    					Zangle = dae.children[i].children[0].Zangle + colladaObjects['landscape'][0]['Zangle'];
		    					if ((angleX == Math.PI && angleY == Math.PI) || (angleX == -Math.PI && angleY == -Math.PI) || (angleX == 0 && angleY == 0)){
		    						rotateChild(dae.children[i], -Zangle);	
		    					} else {
		    						rotateChild(dae.children[i], Zangle);	
		    					}
		    				}
		    				rotateAsBuilding(dae.children[i]);
		    			}
		    		}
		    	}

		    	function rotateChild(node, Zangle){
		    		if (node.name.indexOf('building') != -1){
		    			//ищем центр building, для этого создаем plane
		    			var planeGeometry = new THREE.Geometry();		
		    			$.each(node.children[0].Geometry, function(index){
		    				//z
    						x = node.children[0].Geometry[index]['x'];
    						y = node.children[0].Geometry[index]['y'];
							x2 = r(x, y, Zangle, 'x');
							y2 = r(x, y, Zangle, 'y');
							node.children[0].Geometry[index]['x'] = x2;
							node.children[0].Geometry[index]['y'] = y2;

							planeGeometry.vertices.push(
								new THREE.Vector3(x2, y2)
							)
		    			});
		    			$.each(node.children[0].geometry.faces, function(index){
	    					a = node.children[0].geometry.faces[index].a;
	    					b = node.children[0].geometry.faces[index].b;
	    					c = node.children[0].geometry.faces[index].c;
		    				planeGeometry.faces.push(
		    					new THREE.Face3(a, b, c)			
		    				)
		    			});

		    			planeGeometry.computeBoundingSphere();
		    			var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide});
						var p = new THREE.Mesh(planeGeometry, planeMaterial);
						var bbox = new THREE.Box3().setFromObject(p);
						a = getCenter(bbox);
                        node.children[0].Center = new THREE.Vector3(a['x'], a['y'], a['z']);
						scene.add(p);
						scene.remove(p);
		    		}
		    		if (node.children){
		    			for (var i=1; i < node.children.length; i++){
		    				if (node.children[i].children[0].Geometry){
		    					//ищем центр floor, kabinet, для этого создаем plane
		    					var planeGeometry = new THREE.Geometry();
		    					object = node.children[i].children[0];
		    					$.each(object.Geometry, function(index){
		    						//z
		    						x = object.Geometry[index]['x'];
		    						y = object.Geometry[index]['y'];
									x2 = r(x, y, Zangle, 'x');
									y2 = r(x, y, Zangle, 'y');
									object.Geometry[index]['x'] = x2;
									object.Geometry[index]['y'] = y2;

									planeGeometry.vertices.push(
										new THREE.Vector3(x2, y2)
									)
		    					});
				    			$.each(object.geometry.faces, function(index){
									a = object.geometry.faces[index].a;
	    							b = object.geometry.faces[index].b;
	    							c = object.geometry.faces[index].c;
				    				planeGeometry.faces.push(
				    					new THREE.Face3(a, b, c)			
				    				)
		    					});

		    					planeGeometry.computeBoundingSphere();
		    					var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide});
								var p = new THREE.Mesh(planeGeometry, planeMaterial);
								var bbox = new THREE.Box3().setFromObject(p);
								a = getCenter(bbox);
                        		object.Center = new THREE.Vector3(a['x'], a['y'], a['z']);
								scene.add(p);
								scene.remove(p);
		    				}
		    				rotateChild(node.children[i], Zangle);
		    			}
		    		}
		    	}

		    	//Найти offset между Center и CenterNew
		    	offset(dae.children[0]);
		    	function offset(dae){
		    		if (dae.children){
		    			for(var i=0; i < dae.children.length; i++){
		    				if (dae.children[i].Center != undefined && dae.children[i].CenterNew != undefined){
		    					Center = dae.children[i].Center;
		    					CenterNew = dae.children[i].CenterNew;
		    					dae.children[i].Offset = {};
		    					//ищем offset в абсолютной величине
		    					dae.children[i].Offset['x'] = Math.abs(Center['x'] - CenterNew['x']);
		    					dae.children[i].Offset['y'] = Math.abs(Center['y'] - CenterNew['y']);
		    					Offset = dae.children[i].Offset;
		    					//определяем знак для offset
		    					if (CenterNew['x'] + Offset['x'] == Center['x']){

		    					} else if (CenterNew['x'] - Offset['x'] == Center['x']){
		    						Offset['x'] = - Offset['x'];
		    					}

		    					if (CenterNew['y'] + Offset['y'] == Center['y']){

		    					} else if (CenterNew['y'] - Offset['y'] == Center['y']){
		    						Offset['y'] = - Offset['y']
		    					}
		    				}
	    				offset(dae.children[i]);
		    			}
		    		}
		    	}

		    	//Смещаем вершины на значение Offset
		    	addOffsetToVertices(colladaObjects['landscape'][0], 0);
		    	function addOffsetToVertices(dae){
		    		if(dae.children){
		    			for (var i=0; i < dae.children.length; i++){
		    				if (dae.children[i].Offset != undefined && dae.children[i].colladaId == undefined){
		    					Geometry = dae.children[i].Geometry;
		    					Offset = dae.children[i].Offset;
		    					$.each(Geometry, function(index){

	    							if (dae.children[i].Center['x'] > 0 && Offset['x'] > 0) {
		    							Geometry[index]['x'] = Geometry[index]['x'] - Offset['x'];
	    							} else if (dae.children[i].Center['x'] < 0 && Offset['x'] > 0){
	    								Geometry[index]['x'] = Geometry[index]['x'] - Offset['x'];
	    							} else {
	    								Geometry[index]['x'] = Geometry[index]['x'] - Offset['x'];
	    							}

	    							if (dae.children[i].Center['y'] > 0 && Offset['y'] > 0) {
		    							Geometry[index]['y'] = Geometry[index]['y'] - Offset['y'];
	    							} else if (dae.children[i].Center['y'] < 0 && Offset['y'] > 0){
	    								Geometry[index]['y'] = Geometry[index]['y'] + Offset['y'];
	    							} else {
	    								Geometry[index]['y'] = Geometry[index]['y'] - Offset['y'];
	    							}

		    					});
		    				}
		    				addOffsetToVertices(dae.children[i]);
		    			}
		    		}
		    	}

		    	//поворачиваем building на Zangle
		    	rotateBuilding(colladaObjects['landscape'][0]);
		    	function rotateBuilding(dae){
		    		if(dae.children){
		    			for(var i = 0; i < dae.children.length; i++){
		    				if (dae.children[i].name.indexOf('building')!= -1 && dae.children[i].Zangle != undefined){
		    					Zangle = dae.children[i].Zangle;
		    					building = dae.children[i].parent;
		    					building.rotation.z = Zangle;
		    				}
		    				rotateBuilding(dae.children[i]);
		    			}
		    		}
		    	}

		    	//получаем новый центр объектов
		    	//building
		    	newCenter(dae.children[0], 'building');
		    	//floor
		    	newCenter(dae.children[0], 'floor');
		    	//kabinet
		    	newCenter(dae.children[0], 'kabinet');

		    	//ищем центр повернутых фигур
		    	rotateChild(dae.children[0], 0);
		    	//ищем offset
		    	offset(dae.children[0]);
		    	//ещё раз смещаем вершины Geometry
		    	addOffsetToVertices(colladaObjects['landscape'][0], 0);



		    	//наполняем словарь вершин BoxMin BoxMax
		    	fillVerticesDict(colladaObjects['landscape'][0]);
		    	function fillVerticesDict(dae){
		    		if(dae.children){
		    			for(var i = 0; i<dae.children.length; i++){
		    				if (dae.children[i].BoxMin != undefined && dae.children[i].BoxMax != undefined && dae.children[i].name.indexOf('outer') == -1 && dae.children[i].name.indexOf('wall') == -1){
		    					object = dae.children[i];
		    					verticesDict['element'].push({'name':object.name, 'vertices': object.Geometry, 'BoxMin': object.BoxMin, 'BoxMax': object.BoxMax});
		    				}
		    				fillVerticesDict(dae.children[i]);
		    			}
		    		}
		    	}
		    	console.log(sceneOptions);
		    	//записываем результат в БД
/*				$.ajax({
					type:"POST",
					url:"/landscape_save",
        			data: JSON.stringify({'landscape_id': '{{landscape_id}}'.toString(), colladaObjects, verticesDict, sceneOptions}),
       				contentType: "application/json; charset=utf-8",
		            dataType: 'json',
		          	async: true,
		          	success: function(data, textStatus, jqXHR){*/
		          		/*window.location = '/landscapeloadform/success';*/
		          		/*console.log(data);
		          	}
				});*/

				//ищу floor
	    		var floorVert = [];
				var floor_003 = [];
		        lookColladaId(dae, 'floor_002', floor_003);
		        function lookColladaId(dae, text, array){
		        	if (dae.children){
		        		for (var i = 0; i < dae.children.length; i++){
		        			if (dae.children[i].colladaId == text){
		        				array.push(dae.children[i]);
		        				return true
		        			}
		        			lookColladaId(dae.children[i], text, array);
		        		}
		        	}
		        }
		    	$.each(floor_003[0].children[0].Geometry, function(index){
					value = floor_003[0].children[0].Geometry[index];
					floorVert.push({'x': value['x'], 'y': value['y']});
				});
				//проверить плоскость правильно ли отображается
				var planeGeometry = new THREE.Geometry();
				$.each(floorVert, function(index){
					x = floorVert[index]['x'];
					y = floorVert[index]['y'];
					planeGeometry.vertices.push(
						new THREE.Vector3(x, y, 0)
					)
				});
				planeGeometry.faces.push(
					new THREE.Face3(1, 3, 2),
					new THREE.Face3(0, 1, 2)
					/*new THREE.Face3(1, 8, 5),
					new THREE.Face3(5, 2, 0),
					new THREE.Face3(0, 1, 5),
					new THREE.Face3(8, 7, 3),
					new THREE.Face3(1, 6, 8),
					new THREE.Face3(4, 5, 8),
					new THREE.Face3(8, 3, 4)*/
				);			

				planeGeometry.computeBoundingSphere();

				var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide});
				var p = new THREE.Mesh(planeGeometry, planeMaterial);
				/*helper(p);*/
				/*p.rotation.set(0, 0, -0.872, 'XYZ');*/
				scene.add(p);

		    	// helper sphere
		    	/*geometry = new THREE.SphereGeometry(5, 32, 32);
		    	material = new THREE.MeshBasicMaterial({color: 0xbbbbbb});
		    	var sph = new THREE.Mesh(geometry, material);
		    	sph.position.set(25.171, 53.190, 10);
		    	scene.add(sph);*/
		    });
			//фунцкция преобразования вершин отдельных объектов из относительных в абсолютные(dae файл - upaxis - down)
			function verticesTransition(object){
				var xmin = 0;
	           	var xmax = 0;
	           	var ymin = 0;
	           	var ymax = 0;
	           	object.Geometry = [];
	            $.each(object.geometry.vertices, function(index){
	            	object.Geometry.push({'x': 0, 'y': 0});
	            	if (xmin == 0){
	            		xmin = object.geometry.vertices[index].x;
	            	} else if (object.geometry.vertices[index].x < xmin){
	            		xmin = object.geometry.vertices[index].x;
	            	}
	            	if (xmax == 0){
	            		xmax = object.geometry.vertices[index].x;
	            	} else if (object.geometry.vertices[index].x > xmax){
	            		xmax = object.geometry.vertices[index].x;
	            	}

	            	if (ymin == 0){
	            		ymin = object.geometry.vertices[index].y;
	            	} else if (object.geometry.vertices[index] < ymin){
	            		ymin = object.geometry.vertices[index].y;
	            	}
	            	if (ymax == 0){
	            		ymax = object.geometry.vertices[index].y;
	            	} else if (object.geometry.vertices[index].y > ymax){
	            		ymax = object.geometry.vertices[index].y;
	            	}
	            });
				$.each(object.geometry.vertices, function(index){
					x = object.geometry.vertices[index].x;
					y = object.geometry.vertices[index].y;
					if (x == xmin){
						object.Geometry[index].x = object.BoxMin.x;
					}
					if (x == xmax){
						object.Geometry[index].x = object.BoxMax.x;
					}
					if (y == ymin){
						object.Geometry[index].y = object.BoxMin.y;
					}
					if (y == ymax){
						object.Geometry[index].y = object.BoxMax.y;
					}
					//если y отрицательное число
					if (y != ymin && y < 0){
						yDistanse = Math.abs(object.BoxMin.y - object.Center.y);
						k = y/ymin;
						object.Geometry[index].y = object.Center.y - yDistanse*k;
					}
					//ecли у положительное число
					if (y != ymax && y > 0){
						yDistanse = Math.abs(object.Center.y - object.BoxMax.y);
						k = y/ymax;
						object.Geometry[index].y = object.Center.y + yDistanse*k;
					}
					//если x отрицательное число
					if (x != xmin && x < 0){
						xDistanse = Math.abs(object.BoxMin.x - object.Center.x);
						k = x/xmin;
						object.Geometry[index].x = object.Center.x - xDistanse*k;
					}
					//если x положительное число
					if (x != xmax && x > 0){
						xDistanse = Math.abs(object.Center.x - object.BoxMax.x);
						k = x/xmax;
						object.Geometry[index].x = object.Center.x + xDistanse*k;
					}
				});
				//меняем "x" на "y"
				/*$.each(object.Geometry, function(index){
					x = object.Geometry[index].x;
					y = object.Geometry[index].y;
					object.Geometry[index].x = y;
					object.Geometry[index].y = x;
				});*/
			}
			function rz2(y, z, gradus, returning){
				y2 = y * Math.cos(gradus) + z * Math.sin(gradus);
				if (returning == 'y'){
					return y2;
				}
			}

			function rz(x, z, gradus, returning){
				x2 = x * Math.cos(gradus) + z * Math.sin(gradus);
				if (returning == 'x'){
					return x2;
				}
			}

			function r(x, y, gradus, returning){
				/*gradus = gradus * Math.PI/180;*/
				x2 = x * Math.cos(gradus) + y * Math.sin(gradus);
				y2 = -x * Math.sin(gradus) + y * Math.cos(gradus);
				if (returning == 'x'){
					return x2
				} else if(returning == 'y') {
					return y2
				}
			}


			/* позиция камеры по умолчанию */
		    /*camera.position.set(69, 69, -50);*/
		    x = 70;
		    y = -80;
		    z = 50;
		    camera.position.set(x, y, z);
		    sceneOptions['CameraPosition'] = {};
		    sceneOptions['CameraPosition'].x = x;
		    sceneOptions['CameraPosition'].y = y;
		    sceneOptions['CameraPosition'].z = z;
		    /* вверх - это Z*/
		    /*camera.up.set( 0, 0, -1 );*/
		    x = 0;
		    y = 0;
		    z = 1;
		    if (z == 1){
		    	sceneOptions['LightTargetSymbol'] = 1;
		    	sceneOptions['CircleStepSymbol'] = 1;
		    	sceneOptions['GetWallHeightSymbol'] = 1; 
		    } else if (z == -1){
		    	sceneOptions['LightTargetSymbol'] = 0;
		    	sceneOptions['CircleStepSymbol'] = 0;
		    	sceneOptions['GetWallHeightSymbol'] = 0;
		    }
		    camera.up.set(x, y, z);
		    sceneOptions['CameraUp'] = {};
		    sceneOptions['CameraUp'].x = x;
		    sceneOptions['CameraUp'].y = y;
		    sceneOptions['CameraUp'].z = z;

		    scene.add(camera);


		    /*камера. контроль за сменой позиции*/
		    controls = new THREE.OrbitControls( camera, renderer.domElement );
		    /* камера вращается вокруг данных координат*/
		    x = 67;
		    y = 40;
		    z = 0;
		    sceneOptions['ControlsTarget'] = {};
		    sceneOptions['ControlsTarget'].x = x;
		    sceneOptions['ControlsTarget'].y = y;
		    sceneOptions['ControlsTarget'].z = z;
		    controls.target.copy(new THREE.Vector3(x, y, z));
		    //камера смотрит
		    camera.lookAt(new THREE.Vector3(x, y, z));
		    controls.addEventListener( 'change', render );
		    hemi = new THREE.HemisphereLight(0xbbbbbb, 0x0099FF);
		    scene.add(hemi);

		    $("#webGL-container").append(renderer.domElement);

		    /*статистика*/
		    stats = new Stats();        
		    stats.domElement.style.position = 'absolute';
		    stats.domElement.style.left = '0px';
		    stats.domElement.style.top = '0px';     
		    $("#webGL-container").append( stats.domElement );
	    }

	    function render(){
	    }

	    function update(){
    	}

	    function animate(){
        requestAnimationFrame(animate);
        render();
        update();
        stats.update();     
        renderer.render(scene, camera);
	    }

	    init();
  	  animate();


	    $(window).resize(function(){
	        SCREEN_WIDTH = window.innerWidth;
	        SCREEN_HEIGHT = window.innerHeight;
	        camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
	        camera.updateProjectionMatrix();
	        renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
	    });
		</script>
		<script src="{% static 'js/foundation.js' %}"></script>
    <script src="{% static 'js/vendor/what-input.min.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.slider.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.tabs.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.keyboard.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.timerAndImageLoader.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.drilldown.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.motion.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.nest.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.util.mediaQuery.js' %}"></script>
    <script src="{% static 'js/vendor/foundation.accordionMenu.js' %}"></script>
    <script>
      $(document).foundation();
    </script>
	</body>
</html>