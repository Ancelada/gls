<!DOCTYPE HTML>

<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Our WebGl</title>
		{% load staticfiles %}

		<script type="text/javascript" src="{% static 'js/vendor/jquery.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/three.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/dat.gui.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/OrbitControls.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/stats.min.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/helvetiker_regular.typeface.js' %}"></script>
		<script type="text/javascript" src="{% static 'js/ColladaLoader.js' %}"></script>


  		<link rel="stylesheet" href="{% static 'css/foundation.css' %}">
    	<link rel="stylesheet" href="{% static 'css/foundation-icons/foundation-icons.css' %}">
    	<link rel="stylesheet" href="{% static 'css/app.css' %}">
  		<script src="{% static 'js/vendor/modernizr.js' %}"></script>


		<style>
			body{
				margin:0;
				overflow:hidden;
				
			}
		</style>
	</head>
	<body>
		{% csrf_token %}
		<!-- ***блок 3д изображения*** -->
		<!--************************-->
		<div id ="webGL-container"></div>
		<!-- **********шейдеры ******-->
		<!--************************-->
		<script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;
			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( h, exponent ), 0.0 ) ), 1.0 );

			}
		</script>
		<!--************************-->
<!--***********буфер**************-->
		<!--************************-->
	<script>
	var unique = {};
	var cubeGeom = new THREE.BoxGeometry(0.5, 0.5, 0.5, 2, 2, 2);
	var cubeMaterial = new THREE.MeshLambertMaterial({color: 0x0000ff, transparent: true, opacity:0.8});
	var guiControls, datGUI;

	$(document).ready(function(){
		var marks;
		var unum = 0;
		var cron = 0;
		function getVal(){
			var csrf_token = $("input[name='csrfmiddlewaretoken']").val();
	        $.ajax({
	            type: 'POST',
	            url: '/getmarksvalues',
	            data: JSON.stringify(csrf_token),
              contentType: "application/json; charset=utf-8",
            	dataType: 'json',
            	async: false,
	            success: function(data, textStatus, jqXHR){
	            	if (marks){
	            		//проверка на повторение пачки
	            		function verify(){
	            			var doubled = 0;
		            		$.each(data, function(index){
		            			tag_id_new = data[index][0]['tag_id'];
		            			zone_new = data[index][0]['zone'];
		            			$.each(marks, function(index){
		            				tag_id_old = marks[index][0]['tag_id'];
		            				zone_old = marks[index][0]['zone'];
		            				if(tag_id_old == tag_id_new && zone_old == zone_new){
		            					doubled = 1;
		            					return false;
		            				}
		            			});
		            		});
		            		return doubled;
	            		}
	            		var result = verify();
            			//если пачка не повторяется записываем в буфер
	            		if(result == 0){
		            		$.each(data, function(index){
		            			//первая запись в буфере
		            			if(unique[0] == undefined){
		            					unique[0] = data[index][0];
		            					unum += 1;
            					} else {
            						//проверка на уникальность id в буфере
		            				//если нет, записать в массив
	            					tag_id_new = data[index][0]['tag_id'];
	            					doubled = 0;
	            					$.each(unique, function(index){
	            						tag_id_unique = unique[index]['tag_id'];
	            						if (tag_id_new == tag_id_unique){
	            							doubled = 1;
	            							return false;
	            						}
	            					});
	            					if (doubled==0){
	            						unique[unum] = data[index][0];
	            						unum += 1;
	            					}
            					}
		            		});
	            			//таймер, для отслеживания времения между посылками
	            			//переменная cron
	            			function timer(clear){
	            				var milisec = 0;
	            				timer = setInterval(function(){
	            					milisec += 10;
	            					cron = milisec;
	            					if (clear){
	            						milisec += 0;
	            					}
	            				}, 10);
	            			}
										timer(1);
										//запись в буфер позиций метки
										//в том числе повторяющихся
										//меток с разными позициями
										$.each(data, function(index){
											tag_id_new = data[index][0]['tag_id'];
											var ind = index;
											$.each(unique, function(index){
												tag_id_unique = unique[index]['tag_id'];
												if (tag_id_new == tag_id_unique){
													//при совпадении задаем список
													//записываем все повторяющиеся значения 
													unique[index]['data'] = [];
													uind = index;
													no=0;
													$.each(data, function(index){
														if (unique[uind]['tag_id'] == data[index][0]['tag_id']){
															unique[uind]['data'][no] = data[index][0];
															//количество позиций в пачке
															unique[uind]['count'] = no;
															//количество миллисекунд до обновления позиции
															unique[uind]['cron'] = cron;
															no+=1;	
														}
													});
													return false;
												}
											});
										});

										//передача буфера в рендер
										/*console.log(unique);*/
	            		}
	            		marks = data;//не удалять

	            	} else {
		            	marks = data;
	            	}
	            },
	        });
        }

        setInterval(getVal, 1000);
	});
	//************************
	//************************
	//сцена, фон, сетка, камера
	//инициализация
	//************************
	//************************

	//массив меток
	var cube = {};
	var dae;
	var camera;
	var spotLight;
	var cameraTarget;
	var renderer;
	var scene;

	// глобальный объект
	var center;

	function init(){

    /*сцена, камера */
    scene = new THREE.Scene();
    camera =  new THREE.PerspectiveCamera(85, window.innerWidth/window.innerHeight, .1, 1000);
    renderer = new THREE.WebGLRenderer({antialias:true});
    
    /*рендерер;*/
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMapEnabled= true;
    renderer.shadowMapType = THREE.PCFSoftShadowMap;
    
    /*оси*/
    axis = new THREE.AxisHelper(30);
    scene.add(axis);

    /* сетка */
    grid = new THREE.GridHelper(100, 25);
    color = new THREE.Color("rgb(255, 0, 0)");
    grid.setColors(color, 0x000000);
    grid.rotation.x = -0.5* Math.PI
    /*scene.add(grid);*/
    
    //шейдер неба
    var vertexShader = document.getElementById( 'vertexShader' ).textContent;
    var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
    var uniforms = {
        topColor:      { type: "c", value: new THREE.Color(0x000000) },
        bottomColor: { type: "c", value: new THREE.Color( 0x262626 ) },
        offset:         { type: "f", value: 100 },
        exponent:     { type: "f", value: 0.7 }
    }

    //сфера неба
    var skyGeo = new THREE.SphereGeometry( 300, 32, 15 );
    var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

    var sky = new THREE.Mesh( skyGeo, skyMat );
    scene.add( sky );

    //маркеры калибровки
    var markGeom = new THREE.BoxGeometry(0.5, 0.5, 0.5, 2, 2, 2);
    var markMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});
    this.marker6004 = new THREE.Mesh(markGeom, markMaterial);
    marker6004.position.set(39.682, 76.457, 7.6);
    scene.add(marker6004);

    this.marker6045 = new THREE.Mesh(markGeom, markMaterial);
    marker6045.position.set(30.141, 76.426, 8.7);
    scene.add(marker6045);

    this.marker6003 = new THREE.Mesh(markGeom, markMaterial);
    marker6003.position.set(39.8109, 59.531, 7.6);
    scene.add(marker6003);

    this.marker6012 = new THREE.Mesh(markGeom, markMaterial);
    marker6012.position.set(28.649, 59.256, 8.7);
    scene.add(marker6012);

    /* add collada import */
    var loader = new THREE.ColladaLoader();
    /*loader.options.convertUpAxis = true;*/
    loader.load( 'static/js/webgl/models/gls.dae', function ( collada ) {
    	//gls.dae
    	var dae = collada.scene;
    	dae.position.set(28.141,59.087,8.6);//x,z,y- if you think in blender dimensions ;)
    	dae.scale.set(1,1,1);
    	dae.rotation.z = - (Math.PI/2);
    	dae.rotation.x = Math.PI;
    	scene.add(dae);
    	//plane material color
    	plane = dae['children'][0]['children'][0];
    	plane.receiveShadow = true;
    	setMaterialObject(plane, new THREE.MeshPhongMaterial({ color: 0x803131 }));
    	//building material
    	building = dae['children'][0]['children'][1]['children'][0];
        building.visible = false;
    	setMaterialObject(building, new THREE.MeshLambertMaterial({ color: 0xff4800, transparent:true, opacity:0}));
    	//floor1 material
    	elemOfBuilding = dae['children'][0]['children'][1]['children'];
    	//plane & walls
    	$.each(elemOfBuilding, function(value){
    		if(elemOfBuilding[value].name == 'floor1'){
                elemOfBuilding[value]['children'][0].visible = false;
    			setMaterialObject(elemOfBuilding[value]['children'][0], new THREE.MeshLambertMaterial({ color: 0xff4800, transparent:false}));
    			elemOfBuilding[value]['children'][0].castShadow = true;
    			setMaterialObject(elemOfBuilding[value]['children'][1]['children'][0], new THREE.MeshLambertMaterial({ color: 0xff4800, transparent:true, opacity: 0.3}));
    			elemOfBuilding[value]['children'][1]['children'][0].castShadow = true;
    		}
    	});
    	//floor2 material
    	elemOfBuilding = dae['children'][0]['children'][1]['children'];
    	//plane & walls
    	$.each(elemOfBuilding, function(value){
    		if(elemOfBuilding[value].name == 'floor2'){
                elemOfBuilding[value]['children'][0].visible = false;
    			setMaterialObject(elemOfBuilding[value]['children'][0], new THREE.MeshLambertMaterial({ color: 0xffff99, transparent:false}));
    			elemOfBuilding[value]['children'][0].castShadow = true;
    			setMaterialObject(elemOfBuilding[value]['children'][1]['children'][0], new THREE.MeshLambertMaterial({ color: 0xffff99, transparent:true, opacity: 0.3}));
    			elemOfBuilding[value]['children'][1]['children'][0].castShadow = true;
    		}
    	});
    	//floor3 material
    	elemOfBuilding = dae['children'][0]['children'][1]['children'];
    	//plane & walls
    	$.each(elemOfBuilding, function(value){
    		if(elemOfBuilding[value].name == 'floor3'){
                elemOfBuilding[value]['children'][0].visible = false;
    			setMaterialObject(elemOfBuilding[value]['children'][0], new THREE.MeshLambertMaterial({ color: 0x4cb122, transparent:false}));
    			elemOfBuilding[value]['children'][0].castShadow = true;
    			setMaterialObject(elemOfBuilding[value]['children'][2]['children'][0], new THREE.MeshLambertMaterial({ color: 0x4cb122, transparent:true, opacity: 0.3}));
    			elemOfBuilding[value]['children'][2]['children'][0].castShadow = true;
    		}
    	});
    });

    //изменить материал для обектов
    var setMaterialObject = function(obj, material) {
    	obj.material = material;
	}

    //изменить материал для дочерних объектов
    var setMaterialNode = function(node, material) {
		node.material = material;
		if (node.children) {
			for (var i = 0; i < node.children.length; i++) {
  				setMaterialNode(node.children[i], material);
			}
		}
	}

    /*datGUI controls object*/
    guiControls = new function(){
        this.rotationX  = 0.0;
        this.rotationY  = 0.0;
        this.rotationZ  = 0.0;

        this.lightX = 20;
        this.lightY = 35;
        this.lightZ = 40;
        this.intensity = 1;
        this.decay = 8.5;   
        this.distance = 0;
        this.angle = 0.5;
        this.exponent = 0;
        this.shadowCameraNear = 10;
        this.shadowCameraFar = 100;
        this.shadowCameraFov = 50;
        this.shadowCameraVisible=true;
        this.shadowMapWidth=1028;
        this.shadowMapHeight=1028;
        this.shadowBias=0;
        this.shadowDarkness=0.5;        
    }   

    /*adds spot light with starting parameters*/
    spotLight = new THREE.SpotLight(0xffffff);
    spotLight.castShadow = true;
    spotLight.position.set (25, 60, -60);
    spotLight.target.position.set(25, 60, 0);
    spotLight.target.updateMatrixWorld();
    scene.add(spotLight);
    /*console.log(spotLight);*/
              
    spotLight.intensity = guiControls.intensity;        
    spotLight.distance = guiControls.distance;
    spotLight.angle = guiControls.angle;
    spotLight.exponent = guiControls.exponent;
    spotLight.shadowCameraNear = guiControls.shadowCameraNear;
    spotLight.shadowCameraFar = guiControls.shadowCameraFar;
    spotLight.shadowCameraFov = guiControls.shadowCameraFov;
    spotLight.shadowCameraVisible = guiControls.shadowCameraVisible;
    spotLight.shadowBias = guiControls.shadowBias;
    spotLight.shadowDarkness = guiControls.shadowDarkness;

    /*adds controls to scene*/
    datGUI = new dat.GUI();

    datGUI.add(guiControls, 'rotationX',0,1);
    datGUI.add(guiControls, 'rotationY',0,1);   
    datGUI.add(guiControls, 'rotationZ',0,1);

    datGUI.add(guiControls, 'lightX',-60,180);  
    datGUI.add(guiControls, 'lightY',0,180);    
    datGUI.add(guiControls, 'lightZ',-60,180);
        
    datGUI.add(guiControls, 'intensity',0.01, 5).onChange(function(value){
        spotLight.intensity = value;
    });     
    datGUI.add(guiControls, 'distance',0, 1000).onChange(function(value){
        spotLight.distance = value;
    }); 
    datGUI.add(guiControls, 'angle',0.001, 1.570).onChange(function(value){
        spotLight.angle = value;
    });     
    datGUI.add(guiControls, 'exponent',0 ,50 ).onChange(function(value){
        spotLight.exponent = value;
    });
    datGUI.add(guiControls, 'shadowCameraNear',0,100).name("Near").onChange(function(value){        
        spotLight.shadowCamera.near = value;
        spotLight.shadowCamera.updateProjectionMatrix();        
    });
    datGUI.add(guiControls, 'shadowCameraFar',0,5000).name("Far").onChange(function(value){
        spotLight.shadowCamera.far = value;
        spotLight.shadowCamera.updateProjectionMatrix();
    });
    datGUI.add(guiControls, 'shadowCameraFov',1,180).name("Fov").onChange(function(value){
        spotLight.shadowCamera.fov = value;
        spotLight.shadowCamera.updateProjectionMatrix();
    });
    datGUI.add(guiControls, 'shadowCameraVisible').onChange(function(value){
        spotLight.shadowCameraVisible = value;
        spotLight.shadowCamera.updateProjectionMatrix();
    });
    datGUI.add(guiControls, 'shadowBias',0,1).onChange(function(value){
        spotLight.shadowBias = value;
        spotLight.shadowCamera.updateProjectionMatrix();
    });
    datGUI.add(guiControls, 'shadowDarkness',0,1).onChange(function(value){
        spotLight.shadowDarkness = value;
        spotLight.shadowCamera.updateProjectionMatrix();
    });
    datGUI.close();


	/* позиция камеры по умолчанию */
    camera.position.set(69, 69, -50);
    /* вверх - это Z*/
    camera.up.set( 0, 0, -1 );
    scene.add(camera);


    /*камера. контроль за сменой позиции*/
    controls = new THREE.OrbitControls( camera, renderer.domElement );
    /* камера вращается вокруг данных координат*/
    controls.target.copy(new THREE.Vector3(34.141, 67.862, 8.6));
    //камера смотрит
    camera.lookAt(new THREE.Vector3(34.141, 67.862, 8.6));
    controls.addEventListener( 'change', render );
    hemi = new THREE.HemisphereLight(0xbbbbbb, 0x0099FF);
    scene.add(hemi);

    $("#webGL-container").append(renderer.domElement);

    /*статистика*/
    stats = new Stats();        
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';     
    $("#webGL-container").append( stats.domElement );       
	  }

    function render(){

    	if ($.isEmptyObject(unique)==false){
				//проверка наличия элемента на сцене
				$.each(unique, function(index){
					if (unique[index]['mesh']==undefined){
						//добавление элемента на сцену
						unique[index]['mesh'] = new THREE.Mesh(cubeGeom, cubeMaterial);
						scene.add(unique[index]['mesh']);
					}
				});

				$.each(unique, function(index){
					var timeOut = 5000;
					ind = index;
					//прохождение позиций координат
					$.each(unique[ind]['data'], function(index){
						if (unique[ind]['data'][index] != undefined){
							x = unique[ind]['data'][index]['x'];
							y = unique[ind]['data'][index]['y'];
							z = unique[ind]['data'][index]['z'];
							//отрисовка перемещений
							//установка временного интервала
							if (unique[ind]['count'] != 0){
								timeOut = timeOut/unique[ind]['count'];
							}

							unique[ind]['mesh'].position.set(x,y,z);

							timeOut += timeOut;
							//удаление пройденных координат из буфера
							unique[ind]['data'] = jQuery.grep(unique[ind]['data'], function(value){
								return value != unique[ind]['data'][index];
							});

							//проверить, если давно не поступает сигнал удалить из буфера
							/*delay = 20000;
							var a = unique[index]['cron'];
								if (a > delay){
									unique[index]['removed'] = 1;
									scene.remove(unique[index]['mesh']);
								}
								//если сигнал посупил, снова добавить
							if (a < delay && unique[index]['removed'] == 1){
									unique[index]['mesh'] = new THREE.Mesh(cubeGeom, cubeMaterial);
									scene.add(unique[index]['mesh']);
									unique[index]['removed'] = 0;
							}*/
						}
					});
					//oчищаем count
					unique[ind]['count'] = 0;
				});
    	}

    }

    function update(){
    }

    function animate(){
        requestAnimationFrame(animate);
        render();
        update();
        stats.update();     
        renderer.render(scene, camera);
    }

    init();
    animate();


    $(window).resize(function(){
        SCREEN_WIDTH = window.innerWidth;
        SCREEN_HEIGHT = window.innerHeight;
        camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
        camera.updateProjectionMatrix();
        renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
    });
	</script>
	<script src="{% static 'js/foundation/foundation.js' %}"></script>
  	<script src="{% static 'js/foundation/foundation-datepicker.js' %}"></script>
	</body>
</html>